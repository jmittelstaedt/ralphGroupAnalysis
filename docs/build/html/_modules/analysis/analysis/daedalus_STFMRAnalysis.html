

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>analysis.analysis.daedalus_STFMRAnalysis &mdash; Ralph Group Analysis 0.1alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Ralph Group Analysis
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Analysis Classes:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis/AMRAnalysis.html">AMR Analysis Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis/Hall2HarmAnalysis.html">Second Harmonic Hall Analysis Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis/baseAnalysis.html">Base Analysis Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis/daedalusSTFMRAnalysis.html">Daedalus STFMR Analysis Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis/kavliSTFMRAnalysis.html">Kavli STFMR Analysis Class</a></li>
</ul>
<p class="caption"><span class="caption-text">Procedures:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../procedures/AMRProcedure.html">AMR Procedures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../procedures/Hall2HarmProcedure.html">Second Harmonic Hall Procedures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../procedures/daedalusSTFMRProcedure.html">Daedalus STFMR Procedure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../procedures/kavliSTFMRProcedure.html">Kavli STFMR Procedure</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ralph Group Analysis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>analysis.analysis.daedalus_STFMRAnalysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for analysis.analysis.daedalus_STFMRAnalysis</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">leastsq</span><span class="p">,</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">savgol_filter</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">pymeasure.experiment</span> <span class="k">import</span> <span class="n">Results</span>
<span class="kn">from</span> <span class="nn">.baseAnalysis</span> <span class="k">import</span> <span class="n">baseAnalysis</span><span class="p">,</span> <span class="n">analyzedFit</span>
<span class="kn">from</span> <span class="nn">.baseAnalysis</span> <span class="k">import</span> <span class="n">get_coord_selection</span><span class="p">,</span> <span class="n">fit_dataset</span>
<span class="kn">from</span> <span class="nn">..procedures</span> <span class="k">import</span> <span class="n">daedalus_STFMRProcedure</span>

<div class="viewcode-block" id="daedalus_STFMRAnalysis"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis">[docs]</a><span class="k">class</span> <span class="nc">daedalus_STFMRAnalysis</span><span class="p">(</span><span class="n">baseAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to contain all STFMR related functions, and acts as a convenient</span>
<span class="sd">    container for importing and storing datasets etc.</span>
<span class="sd">    Note that:</span>
<span class="sd">    1. this is fairly general, so if you end up sweeping over more stuff</span>
<span class="sd">    than before, it should be able to handle that transparently.</span>
<span class="sd">    2. this is written so that if names of parameters or data columns</span>
<span class="sd">    change, we just need to modify some class variables and all of the</span>
<span class="sd">    analysis should still work.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sweep_ds : xarray.Dataset</span>
<span class="sd">        Dataset containing the data</span>
<span class="sd">    fit_ds : xarray.Dataset or None</span>
<span class="sd">        dataset containing fit parameters. ``None`` if fitting has not been done.</span>
<span class="sd">    procedure_swept_col : str</span>
<span class="sd">        column swept in the procedure</span>
<span class="sd">    series_swept_params : list of str</span>
<span class="sd">        parameters swept in the series</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Gyromagnetic Ratio in GHz/T</span>
<span class="sd">    mu0 : float</span>
<span class="sd">        Permeability of Free Space</span>
<span class="sd">    hbar : float</span>
<span class="sd">        Planck&#39;s Reduced Constant</span>
<span class="sd">    echarge : float</span>
<span class="sd">        magnitude of electron charnge</span>
<span class="sd">    muB : float</span>
<span class="sd">        Bohr Magneton</span>
<span class="sd">    procedure : pymeasure.experiment.Procedure</span>
<span class="sd">        The procedure class which created the data files. Used for importing </span>
<span class="sd">        using PyMeasure</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># PyMeasure procedure names of parameters, for accessing things from</span>
    <span class="c1"># xarray Datasets</span>
    <span class="n">BFIELD_DIM</span> <span class="o">=</span> <span class="s1">&#39;field_strength&#39;</span>
    <span class="n">ANGLE_DIM</span> <span class="o">=</span> <span class="s1">&#39;field_azimuth&#39;</span>
    <span class="n">FREQUENCY_DIM</span> <span class="o">=</span> <span class="s1">&#39;rf_freq&#39;</span>
    <span class="n">X_DATA_VAR</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">28.024</span> <span class="c1">#GHz*Radians/T</span>
    <span class="n">mu0</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">1e-7</span> <span class="c1">#N/A^2 i.e. T*m/A   SI for LYFE!!!!!</span>
    <span class="n">hbar</span> <span class="o">=</span> <span class="mf">6.626</span><span class="o">*</span><span class="mf">1e-34</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">echarge</span> <span class="o">=</span> <span class="mf">1.602e-19</span>
    <span class="n">muB</span> <span class="o">=</span> <span class="mf">9.27400968</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">24</span><span class="p">)</span>
    <span class="n">rad2deg</span> <span class="o">=</span> <span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">deg2rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>

    <span class="c1"># TODO: Give each one a name for plotting results? Could be useful.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates the analysis object with an empty dataset with the correct</span>
<span class="sd">        dimension names. Records the guesses for initial parameters for</span>
<span class="sd">        fitting of the resonances.</span>

<span class="sd">        Must load data with a separate method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">procedure_swept_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series_swept_params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FREQUENCY_DIM</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">procedure</span> <span class="o">=</span> <span class="n">daedalus_STFMRProcedure</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzed_fit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_angle_fit_params</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.load_utilsweep"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.load_utilsweep">[docs]</a>    <span class="k">def</span> <span class="nf">load_utilsweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direc</span><span class="p">,</span> <span class="n">fnames</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads utilsweep. If fnames is not specified, assumes only utilsweep</span>
<span class="sd">        files are in the directory and loads them all.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        direc : str</span>
<span class="sd">            Directory containing UtilSweep files to include in the sweep.</span>
<span class="sd">        fnames : list of str, optional</span>
<span class="sd">            List of additional data files to include</span>
<span class="sd">        header : str, optional</span>
<span class="sd">            beginning of the data filenames</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fnames</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">direc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">direc</span><span class="p">,</span> <span class="n">f</span><span class="p">)):</span>
                    <span class="n">fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">direc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Given directory does not exist!&quot;</span><span class="p">)</span>

        <span class="n">procedure_swept_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span>
        <span class="n">series_swept_params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">FREQUENCY_DIM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">]</span>

        <span class="n">ex_result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">direc</span><span class="p">,</span><span class="n">fnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># record data columns, except one we swept over. Will handle it separately</span>
        <span class="n">file_data_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LockinOnex&#39;</span><span class="p">]</span>
        <span class="n">data_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">col_size</span> <span class="o">=</span> <span class="n">ex_result</span><span class="p">[</span><span class="s1">&#39;Field(nominal)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="n">new_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">procedure_swept_col</span><span class="p">]</span> <span class="o">+</span> <span class="n">series_swept_params</span><span class="p">)</span>
        <span class="n">swept_col_data</span> <span class="o">=</span> <span class="n">ex_result</span><span class="p">[</span><span class="s1">&#39;Field(nominal)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># need data_var data to have the correct shape as an array so that</span>
        <span class="c1"># all coordinates are taken seriously by the dataset. This exists to</span>
        <span class="c1"># reshape the data column into the correct shape</span>
        <span class="n">reshape_helper</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">series_swept_params</span><span class="p">)</span>

        <span class="c1"># we need to get the ball rolling. Add the first data to growing_ds</span>
        <span class="c1"># create data_vars, appropriately reshaped</span>
        <span class="n">new_data_vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">fcol</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_cols</span><span class="p">,</span> <span class="n">file_data_cols</span><span class="p">):</span>
            <span class="n">new_data_vars</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">new_dims</span><span class="p">,</span>
                <span class="n">ex_result</span><span class="p">[</span><span class="n">fcol</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">col_size</span><span class="p">,</span><span class="o">*</span><span class="n">reshape_helper</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># create new columns, with all from series_swept_params only having one</span>
        <span class="c1"># coordinate value (hence the need for reshaping)</span>
        <span class="n">phi0</span> <span class="o">=</span> <span class="n">fnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">fnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">7</span><span class="p">]</span>
        <span class="n">params0</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">f0</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">phi0</span><span class="p">))</span>
        <span class="n">new_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">procedure_swept_col</span><span class="p">:</span> <span class="n">swept_col_data</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">series_swept_params</span><span class="p">):</span>
            <span class="n">new_coords</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">params0</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="n">growing_ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span><span class="o">=</span><span class="n">new_data_vars</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">)</span>

        <span class="c1"># load the rest of the procedure data files</span>
        <span class="c1"># if ur lookin here b/c you got an error and were trying to load A SINGLE</span>
        <span class="c1"># procedure data file 1. i&#39;m sorry this is implemented poorly 2. ur a dumbass</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">rslt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">direc</span><span class="p">,</span><span class="n">f</span><span class="p">))</span>

            <span class="c1"># new data vars (but same dims)</span>
            <span class="n">new_data_vars</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">fcol</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_cols</span><span class="p">,</span> <span class="n">file_data_cols</span><span class="p">):</span>
                <span class="n">new_data_vars</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">new_dims</span><span class="p">,</span>
                    <span class="n">rslt</span><span class="p">[</span><span class="n">fcol</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">col_size</span><span class="p">,</span><span class="o">*</span><span class="n">reshape_helper</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># new coords (but same dims)</span>
            <span class="n">phi0</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">f0</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">7</span><span class="p">]</span>
            <span class="n">params0</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">f0</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">phi0</span><span class="p">))</span>
            <span class="n">new_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">procedure_swept_col</span><span class="p">:</span> <span class="n">swept_col_data</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">series_swept_params</span><span class="p">):</span>
                <span class="n">new_coords</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">params0</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="c1"># make dataset corresponding to new procedure data file</span>
            <span class="n">fresh_ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span><span class="o">=</span><span class="n">new_data_vars</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">)</span>

            <span class="n">growing_ds</span> <span class="o">=</span> <span class="n">fresh_ds</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">growing_ds</span><span class="p">)</span>

        <span class="c1"># sort so all coordinates are in a sensible order</span>
        <span class="n">growing_ds</span> <span class="o">=</span> <span class="n">growing_ds</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">growing_ds</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span> <span class="o">=</span> <span class="n">growing_ds</span> <span class="c1"># Now fully grown :&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">data_vars</span></div>

    <span class="k">def</span> <span class="nf">omega0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Meff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resonant frequency&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">Meff</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">B0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Meff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resonant field&quot;&quot;&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">Meff</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Meff</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Delta_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expected formula for the Delta parameter in lorentzians&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">alpha</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">+</span><span class="n">offset</span>

    <span class="k">def</span> <span class="nf">sym_lor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symmetric lorentzian&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">*</span><span class="n">Delta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">B0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asym_lor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Asymmetric lorentzian&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">A</span><span class="o">*</span><span class="n">Delta</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">B0</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">B0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">total_lor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symmetric + Asymmetric lorentzian with offset&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_lor</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">B0</span><span class="p">,</span><span class="n">Delta</span><span class="p">,</span><span class="n">S</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">asym_lor</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">B0</span><span class="p">,</span><span class="n">Delta</span><span class="p">,</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="nf">resonance_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience function used for fitting with leastsq.</span>
<span class="sd">        Unpacks parameters and passes them to total_lor&quot;&quot;&quot;</span>
        <span class="n">B0</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_lor</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">B0</span><span class="p">,</span><span class="n">Delta</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resonance_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function calculating residulals from STFMR resonances, for use with</span>
<span class="sd">        leastsq.</span>

<span class="sd">        Harsh penalty for Delta parameter being negative or the constant offset</span>
<span class="sd">        being much larger than the mean.</span>

<span class="sd">        p = [B0, Delta, S, A, offset]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">penalty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">penalty</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">&gt;</span><span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">+</span><span class="mi">150</span><span class="p">:</span>
            <span class="n">penalty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">penalty</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonance_model</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span><span class="o">/</span><span class="n">error</span>

    <span class="k">def</span> <span class="nf">fit_resonance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">pguess</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a *single* STFMR resonance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da : xarray.DataArray</span>
<span class="sd">            Array to fit over with the field being the only (meaningful)</span>
<span class="sd">            dimension and containing lockin X as values.</span>
<span class="sd">        pguess : list</span>
<span class="sd">            initial guess for the fit parameters. Structure:</span>
<span class="sd">            ``p = [B0, Delta, S, A, offset]``</span>
<span class="sd">        error : np.array or None</span>
<span class="sd">            array of errors to use. If not given, uses 1 for every point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        popt : list</span>
<span class="sd">            List of optimal parameters</span>
<span class="sd">        copt : np.array</span>
<span class="sd">            The covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: Find a better way of dealing with errors. What we&#39;re doing</span>
            <span class="c1"># *should* be the same as passing an array of ones, but it is</span>
            <span class="c1"># not. We need the constant array to have a reasonable amplitude</span>
            <span class="c1"># compared to the data points to not get nonsensical errors.</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;mirror&#39;</span><span class="p">)</span>
            <span class="n">error_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">filt</span> <span class="o">-</span> <span class="n">da</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">error_amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">popt</span><span class="p">,</span> <span class="n">copt</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">leastsq</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resonance_residual</span><span class="p">,</span>
            <span class="n">pguess</span><span class="p">,</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">error</span><span class="p">),</span>
            <span class="n">maxfev</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
            <span class="n">full_output</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">copt</span>

    <span class="c1"># TODO: make this guessing better/smarter somehow...</span>
    <span class="k">def</span> <span class="nf">guess_resonance_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">Meff</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">S45</span><span class="p">,</span> <span class="n">A45</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Guesses parameters for the resonance for this data&quot;&quot;&quot;</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">SAsign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">)</span>
                         <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.01</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">B0</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Meff</span><span class="p">),</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">S45</span><span class="o">*</span><span class="n">SAsign</span><span class="p">,</span> <span class="n">A45</span><span class="o">*</span><span class="n">SAsign</span><span class="p">,</span>
                         <span class="n">offset</span><span class="p">])</span>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.fit_resonances"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.fit_resonances">[docs]</a>    <span class="k">def</span> <span class="nf">fit_resonances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Meff_guess</span><span class="p">,</span> <span class="n">Delta_guess</span><span class="p">,</span> <span class="n">S45_guess</span><span class="p">,</span> <span class="n">A45_guess</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">selections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits all of the resonances.</span>

<span class="sd">        Fits resonances across the different coordinates scanned in</span>
<span class="sd">        the sweep (frequency, angle...) and record the results in a new dataset</span>
<span class="sd">        which shares all dims and coordinates except field (since we are fitting</span>
<span class="sd">        over that). Separates positive and negative field resonances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Meff_guess : float</span>
<span class="sd">            guess of Meff</span>
<span class="sd">        Delta_guess : float</span>
<span class="sd">            guess of lorentzian linewidth</span>
<span class="sd">        S45_guess : float</span>
<span class="sd">            Guess of symmetric amplitude of the lorentzian with ang(B, I)=45</span>
<span class="sd">        A45_guess : float</span>
<span class="sd">            Guess of antisymmetric amplitude of the lorentzian with ang(B, I)=45</span>
<span class="sd">        **selections</span>
<span class="sd">            keywords should be names of ``dims`` besides the field dim.</span>
<span class="sd">            values should eitherbe single coordinate values or lists of coordinate</span>
<span class="sd">            values of those ``dims``. Only data with coordinates given by selections</span>
<span class="sd">            have parameter guesses generated. If no selections given, guesses are</span>
<span class="sd">            generated for everything</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Saves everything to</span>
<span class="sd">            :attr:`~analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.fit_ds`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fit parameters to save in new dataset</span>
        <span class="n">fit_dvars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;B0_pos&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta_pos&#39;</span><span class="p">,</span> <span class="s1">&#39;S_pos&#39;</span><span class="p">,</span> <span class="s1">&#39;A_pos&#39;</span><span class="p">,</span> <span class="s1">&#39;offset_pos&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;B0_pos_err&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta_pos_err&#39;</span><span class="p">,</span> <span class="s1">&#39;S_pos_err&#39;</span><span class="p">,</span> <span class="s1">&#39;A_pos_err&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;offset_pos_err&#39;</span><span class="p">,</span> <span class="s1">&#39;B0_neg&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta_neg&#39;</span><span class="p">,</span> <span class="s1">&#39;S_neg&#39;</span><span class="p">,</span> <span class="s1">&#39;A_neg&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;offset_neg&#39;</span><span class="p">,</span> <span class="s1">&#39;B0_neg_err&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta_neg_err&#39;</span><span class="p">,</span> <span class="s1">&#39;S_neg_err&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;A_neg_err&#39;</span><span class="p">,</span> <span class="s1">&#39;offset_neg_err&#39;</span><span class="p">]</span>

        <span class="c1"># Get coordinate selections and instantiate empty fit dataset</span>
        <span class="n">remaining_dims</span><span class="p">,</span> <span class="n">coord_combos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span> <span class="o">=</span> <span class="n">get_coord_selection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">,</span>
            <span class="n">gen_empty_ds</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">new_dvar_names</span> <span class="o">=</span> <span class="n">fit_dvars</span><span class="p">,</span>
            <span class="o">**</span><span class="n">selections</span>
        <span class="p">)</span>

        <span class="c1"># save fit guesses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Meff_guess</span> <span class="o">=</span> <span class="n">Meff_guess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Delta_guess</span> <span class="o">=</span> <span class="n">Delta_guess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S45_guess</span> <span class="o">=</span> <span class="n">S45_guess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A45_guess</span> <span class="o">=</span> <span class="n">A45_guess</span>

        <span class="c1"># Fit the resonance for each coord combo and record results</span>
        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">coord_combos</span><span class="p">:</span>
            <span class="n">selection_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">remaining_dims</span><span class="p">,</span> <span class="n">combo</span><span class="p">))</span>
            <span class="n">pos_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">X_DATA_VAR</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">selection_dict</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="p">)</span>
            <span class="n">neg_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">X_DATA_VAR</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">selection_dict</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="p">)</span>

            <span class="n">pos_guess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_resonance_params</span><span class="p">(</span>
                <span class="n">pos_da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">selection_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">FREQUENCY_DIM</span><span class="p">],</span>
                <span class="n">selection_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Meff_guess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Delta_guess</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S45_guess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A45_guess</span>
            <span class="p">)</span>
            <span class="n">neg_guess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_resonance_params</span><span class="p">(</span>
                <span class="n">neg_da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">selection_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">FREQUENCY_DIM</span><span class="p">],</span>
                <span class="n">selection_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Meff_guess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Delta_guess</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S45_guess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A45_guess</span>
            <span class="p">)</span>

            <span class="c1"># compute the fits and find 1 SD errors on parameters</span>
            <span class="c1"># (should be the right way to get errors, based on curve_fit docs)</span>
            <span class="c1"># TODO: Handle when fitting fails</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pos_fit</span><span class="p">,</span> <span class="n">pos_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_resonance</span><span class="p">(</span><span class="n">pos_da</span><span class="p">,</span> <span class="n">pos_guess</span><span class="p">)</span>
                <span class="n">neg_fit</span><span class="p">,</span> <span class="n">neg_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_resonance</span><span class="p">(</span><span class="n">neg_da</span><span class="p">,</span> <span class="n">neg_guess</span><span class="p">)</span>
                <span class="n">pos_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pos_cov</span><span class="p">))</span>
                <span class="n">neg_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">neg_cov</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># if fitting fails, set parameters to nans</span>
                <span class="n">pos_fit</span><span class="p">,</span> <span class="n">pos_err</span> <span class="o">=</span> <span class="n">pos_guess</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">pos_guess</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">neg_fit</span><span class="p">,</span> <span class="n">neg_err</span> <span class="o">=</span> <span class="n">neg_guess</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">neg_guess</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>


            <span class="c1"># record fit params.</span>
            <span class="c1"># IDK a better way to do this assignment unfortunately :(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;B0_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span>  \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;Delta_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;S_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;A_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;offset_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_fit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;B0_pos_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span>  \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;Delta_pos_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;S_pos_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;A_pos_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;offset_pos_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_err</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;B0_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;Delta_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;S_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;A_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;offset_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_fit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;B0_neg_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;Delta_neg_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;S_neg_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;A_neg_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">],</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="p">[</span><span class="s1">&#39;offset_neg_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selection_dict</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_err</span></div>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.plot_resonances"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.plot_resonances">[docs]</a>    <span class="k">def</span> <span class="nf">plot_resonances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overlay_fits</span> <span class="o">=</span>  <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">selections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots all resonances subject to the given coordinate constraints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        overlay_fits : bool</span>
<span class="sd">            whether to overlay fits on the data</span>
<span class="sd">        selections</span>
<span class="sd">            keywords should be names of ``dims`` besides the ``field`` dim.</span>
<span class="sd">            values should eitherbe single coordinate values or lists of coordinate</span>
<span class="sd">            values of those ``dims``. Only data with coordinates given by selections</span>
<span class="sd">            have parameter guesses generated. If no selections given, guesses are</span>
<span class="sd">            generated for everything</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Plots requested plots.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">overlay_fits</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;You must fit the resonances before overlaying fits&#39;</span><span class="p">)</span>

        <span class="n">remaining_dims</span><span class="p">,</span> <span class="n">coord_combos</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_coord_selection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">,</span>
            <span class="o">**</span><span class="n">selections</span>
        <span class="p">)</span>

        <span class="c1"># plot the resonances for each coordinate combination</span>
        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">coord_combos</span><span class="p">:</span>
            <span class="c1"># construct dict to select appropriate resonance and plot</span>
            <span class="n">selection_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">remaining_dims</span><span class="p">,</span> <span class="n">combo</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">X_DATA_VAR</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">selection_dict</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
            <span class="c1"># overlay fit resonance, if requested</span>
            <span class="k">if</span> <span class="n">overlay_fits</span><span class="p">:</span>
                <span class="c1"># get positive and negative field points</span>
                <span class="n">pos_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">neg_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># convert this into an evenly spaced, relatively dense domain</span>
                <span class="n">pos_dom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">pos_pts</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">pos_pts</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">200</span><span class="p">)</span>
                <span class="n">neg_dom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">neg_pts</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">neg_pts</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">200</span><span class="p">)</span>

                <span class="n">fit_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">selection_dict</span><span class="p">)</span>

                <span class="c1"># Use fit parameters to get the fit function points</span>
                <span class="n">pos_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_lor</span><span class="p">(</span>
                    <span class="n">pos_dom</span><span class="p">,</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;B0_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;Delta_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;S_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;A_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;offset_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">neg_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_lor</span><span class="p">(</span>
                    <span class="n">neg_dom</span><span class="p">,</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;B0_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;Delta_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;S_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;A_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;offset_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos_dom</span><span class="p">,</span> <span class="n">pos_fit</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neg_dom</span><span class="p">,</span> <span class="n">neg_fit</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.plot_fit_resonances"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.plot_fit_resonances">[docs]</a>    <span class="k">def</span> <span class="nf">plot_fit_resonances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">selections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot just the fits to the resonances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **selections</span>
<span class="sd">            keywords should be names of ``dims`` besides the field dim.</span>
<span class="sd">            values should eitherbe single coordinate values or lists of coordinate</span>
<span class="sd">            values of those ``dims``. Only data with coordinates given by selections</span>
<span class="sd">            have parameter guesses generated. If no selections given, guesses are</span>
<span class="sd">            generated for everything</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Plots requested plots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;You must fit the resonances before overlaying fits&#39;</span><span class="p">)</span>

        <span class="n">remaining_dims</span><span class="p">,</span> <span class="n">coord_combos</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_coord_selection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">,</span>
            <span class="o">**</span><span class="n">selections</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">coord_combos</span><span class="p">:</span>
            <span class="c1"># construct dict to select appropriate resonance</span>
            <span class="n">selection_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">remaining_dims</span><span class="p">,</span> <span class="n">combo</span><span class="p">))</span>

            <span class="c1"># get positive and negative field points</span>
            <span class="n">pos_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">neg_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># convert this into an evenly spaced, relatively dense domain</span>
            <span class="n">pos_dom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">pos_pts</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">pos_pts</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">200</span><span class="p">)</span>
            <span class="n">neg_dom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">neg_pts</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">neg_pts</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">200</span><span class="p">)</span>

            <span class="n">fit_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">selection_dict</span><span class="p">)</span>

            <span class="c1"># Use fit parameters to get the fit function points</span>
            <span class="n">pos_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_lor</span><span class="p">(</span>
                <span class="n">pos_dom</span><span class="p">,</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;B0_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;Delta_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;S_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;A_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;offset_pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">neg_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_lor</span><span class="p">(</span>
                <span class="n">neg_dom</span><span class="p">,</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;B0_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;Delta_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;S_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;A_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;offset_neg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos_dom</span><span class="p">,</span> <span class="n">pos_fit</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neg_dom</span><span class="p">,</span> <span class="n">neg_fit</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Field (T)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Fit resonance&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">selection_dict</span><span class="p">))</span> <span class="c1"># ugly but idk how to make it better</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.separate_field_data"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.separate_field_data">[docs]</a>    <span class="k">def</span> <span class="nf">separate_field_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_offset</span><span class="o">=</span><span class="mf">270.</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Separates the positive and negative field data and assigns the negative</span>
<span class="sd">        field data to an angle 180 deg from the corresponding positive field</span>
<span class="sd">        data. Shifts the angle coordinates as well if requested.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phi_offset : float</span>
<span class="sd">            Angle to offset the angles by. If ``reverse`` is ``True``, we do</span>
<span class="sd">            ``phi_offset - phi``, otherwise ``phi - phi_offset``</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether to reverse the angular coordinates as well, i.e. go from</span>
<span class="sd">            increasing phi meaning clockwise to counter-clockwise</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Modifies :attr:`~.daedalus_STFMRAnalysis.sweep_ds` in place</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pfield</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nfield</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Assume positive and negative field points are (nominally) the same.</span>
        <span class="c1"># this is not too great, but w/e. Better for new procedures since</span>
        <span class="c1"># calibrations were inverted</span>
        <span class="n">nfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">]</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="n">nfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># QUESTION: is this how we want to handle offsets?</span>
        <span class="n">nfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">-=</span> <span class="n">phi_offset</span>
        <span class="n">pfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">-=</span> <span class="n">phi_offset</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">nfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">pfield</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pfield</span><span class="p">,</span><span class="n">nfield</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;field_azimuth&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="o">.</span><span class="n">data_vars</span></div>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.guess_separated_resonance_params"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.guess_separated_resonance_params">[docs]</a>    <span class="k">def</span> <span class="nf">guess_separated_resonance_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">field_azimuth</span><span class="p">,</span> <span class="n">rf_freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Guesses resonance parameters. For use in</span>
<span class="sd">        :meth:`~.daedalus_STFMRAnalysis.fit_separated_resonances`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Data to guess parameters of</span>
<span class="sd">        field : np.ndarray</span>
<span class="sd">            Field strengths of data points to fit</span>
<span class="sd">        field_azimuth : float</span>
<span class="sd">            Azimuthal angle of field with respect to device angle</span>
<span class="sd">        rf_freq : float</span>
<span class="sd">            RF frequency of applied current</span>
<span class="sd">        temperature : float</span>
<span class="sd">            Temperature measurements were made at</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of guesses of the resonance parameters. Format:</span>
<span class="sd">            ``[B0, Delta, S, A, offset]``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">SAsign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">field_azimuth</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">)</span>
                         <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">field_azimuth</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.01</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">B0</span><span class="p">(</span><span class="n">rf_freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Meff_guess</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">Delta_formula</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_guess</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rf_freq</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">S45_guess</span><span class="o">*</span><span class="n">SAsign</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A45_guess</span><span class="o">*</span><span class="n">SAsign</span><span class="p">,</span> <span class="n">offset</span><span class="p">])</span></div>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.fit_separated_resonances"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.fit_separated_resonances">[docs]</a>    <span class="k">def</span> <span class="nf">fit_separated_resonances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Meff_guess</span><span class="p">,</span> <span class="n">alpha_guess</span><span class="p">,</span> <span class="n">S45_guess</span><span class="p">,</span>
                                 <span class="n">A45_guess</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits resonances after</span>
<span class="sd">        :meth:`~.daedalus_STFMRAnalysis.separate_field_data`</span>
<span class="sd">        is ran.</span>

<span class="sd">        This just uses ``curve_fit`` and is a thin wrapper around</span>
<span class="sd">        :func:`~analysis.analysis.baseAnalysis.fit_dataset`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Meff_guess : float</span>
<span class="sd">            guess of Meff</span>
<span class="sd">        alpha_guess : float</span>
<span class="sd">            guess of magnet damping</span>
<span class="sd">        S45_guess : float</span>
<span class="sd">            Guess of symmetric amplitude of the lorentzian with ang(B, I)=45</span>
<span class="sd">        A45_guess : float</span>
<span class="sd">            Guess of antisymmetric amplitude of the lorentzian with ang(B, I)=45</span>
<span class="sd">        kwargs</span>
<span class="sd">            can be:</span>
<span class="sd">            - names of ``dims`` of</span>
<span class="sd">            :attr:`~.daedalus_STFMRAnalysis.sweep_ds`</span>
<span class="sd">            values should eitherbe single coordinate values or lists of coordinate</span>
<span class="sd">            values of those dims. Only data with coordinates given by selections</span>
<span class="sd">            are fit to . If no selections given, everything is fit to.</span>
<span class="sd">            - kwargs of ``curve_fit``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Saves the results into</span>
<span class="sd">            :attr:`~analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.res_fit`</span>
<span class="sd">            as an :class:`~analysis.analysis.baseAnalysis.analyzedFit` object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: check that separate_pnfield_data was ran.</span>

        <span class="c1"># save fit guesses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Meff_guess</span> <span class="o">=</span> <span class="n">Meff_guess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_guess</span> <span class="o">=</span> <span class="n">alpha_guess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S45_guess</span> <span class="o">=</span> <span class="n">S45_guess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A45_guess</span> <span class="o">=</span> <span class="n">A45_guess</span>

        <span class="c1"># Bound parameters so that linewidth is always nonnegative.</span>
        <span class="n">lobounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="n">upbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">res_fit</span> <span class="o">=</span> <span class="n">fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_lor</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">guess_separated_resonance_params</span><span class="p">,</span>
                                   <span class="p">[</span><span class="s1">&#39;B0&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_DATA_VAR</span><span class="p">,</span>
                                   <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">lobounds</span><span class="p">,</span> <span class="n">upbounds</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.plot_separated_resonances"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.plot_separated_resonances">[docs]</a>    <span class="k">def</span> <span class="nf">plot_separated_resonances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots just the resonances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Passed along directly to :func:`analysis.analysis.baseAnalysis.plot_dataset`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plot_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_ds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BFIELD_DIM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_DATA_VAR</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.combine_fit_params_inplane"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.combine_fit_params_inplane">[docs]</a>    <span class="k">def</span> <span class="nf">combine_fit_params_inplane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi0</span> <span class="o">=</span> <span class="mi">270</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines fit parameters if measurements had inplane fields</span>

<span class="sd">        Since positive and negative fields, when the field is in-plane,</span>
<span class="sd">        correspond to phi and ``phi+180``, we should combine them together into</span>
<span class="sd">        a single dataset which goes over a full period in phi. We also negate</span>
<span class="sd">        ``phi`` since daedalus rotate&#39;s clockwise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phi0 : float</span>
<span class="sd">            the offset angle to shift things by.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Saves shifted dataset to ``combined_angle_fit_params``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make lists of data variable names to extract</span>
        <span class="n">fit_dvars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;B0&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">]</span>
        <span class="n">neg_dvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">dvar</span> <span class="o">+</span> <span class="s1">&#39;_neg&#39;</span> <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">fit_dvars</span><span class="p">]</span>
        <span class="n">neg_dvars</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dvar</span> <span class="o">+</span> <span class="s1">&#39;_err&#39;</span> <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">neg_dvars</span><span class="p">]</span>
        <span class="n">pos_dvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">dvar</span> <span class="o">+</span> <span class="s1">&#39;_pos&#39;</span> <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">fit_dvars</span><span class="p">]</span>
        <span class="n">pos_dvars</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dvar</span> <span class="o">+</span> <span class="s1">&#39;_err&#39;</span> <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">pos_dvars</span><span class="p">]</span>
        <span class="n">fit_dvars</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dvar</span> <span class="o">+</span> <span class="s1">&#39;_err&#39;</span> <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">fit_dvars</span><span class="p">]</span>

        <span class="c1"># make datasets of positive and negative dvars, rename to just</span>
        <span class="c1"># base dvar names</span>
        <span class="n">neg_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">pos_dvars</span><span class="p">)</span>
        <span class="n">neg_ds</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">neg_dvars</span><span class="p">,</span> <span class="n">fit_dvars</span><span class="p">)),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pos_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_ds</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">neg_dvars</span><span class="p">)</span>
        <span class="n">pos_ds</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pos_dvars</span><span class="p">,</span> <span class="n">fit_dvars</span><span class="p">)),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># shift the phi coordinates</span>
        <span class="n">neg_ds</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi0</span> <span class="o">-</span> <span class="n">neg_ds</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">180</span>
        <span class="n">pos_ds</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi0</span> <span class="o">-</span> <span class="n">pos_ds</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># recombine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined_angle_fit_params</span> <span class="o">=</span> <span class="n">pos_ds</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">neg_ds</span><span class="p">)</span></div>
        <span class="c1"># self.combined_analyzed_fit = analyzedFit(</span>
        <span class="c1">#     self.combined_angle_fit_params,</span>
        <span class="c1">#     self.sweep_ds</span>
        <span class="c1"># )</span>

<div class="viewcode-block" id="daedalus_STFMRAnalysis.fit_azimuthal_dependence_inplane"><a class="viewcode-back" href="../../../analysis/daedalusSTFMRAnalysis.html#analysis.analysis.daedalus_STFMRAnalysis.daedalus_STFMRAnalysis.fit_azimuthal_dependence_inplane">[docs]</a>    <span class="k">def</span> <span class="nf">fit_azimuthal_dependence_inplane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_func</span><span class="p">,</span> <span class="n">guess_func</span><span class="p">,</span> <span class="n">yname</span><span class="p">,</span>
                                         <span class="n">param_names</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits angular dependence of some previously fit parameters. Thin wrapper</span>
<span class="sd">        around :func:`~analysis.analysis.baseAnalysis.fit_dataset`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fit_func : function</span>
<span class="sd">            Function to fit</span>
<span class="sd">        guess_func : function</span>
<span class="sd">            function to generate guesses of parameters. Arguments must be:</span>
<span class="sd">            - 1D numpy array of y data</span>
<span class="sd">            - numpy array of x data</span>
<span class="sd">            - keyword arguments, with the keywords being all dims of</span>
<span class="sd">            :attr:`~.daedalus_STFMRAnalysis.fit_ds`. Values passed will be</span>
<span class="sd">            individual floats of coordinate values corresponding to those ``dims``.</span>
<span class="sd">            All arguments must be accepted, not all must be used.</span>
<span class="sd">            Must return a list of guesses to the parameters, in the order given in</span>
<span class="sd">            param_names</span>
<span class="sd">        yname : str</span>
<span class="sd">            Name of parameter (``data_var``) which we will fit over</span>
<span class="sd">        param_names : list of str</span>
<span class="sd">            Names of parameters of ``fit_func``, in order.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            can be:</span>
<span class="sd">            - names of ``dims`` of :attr:`~.daedalus_STFMRAnalysis.fit_ds`</span>
<span class="sd">            values should eitherbe single coordinate values or lists of coordinate</span>
<span class="sd">            values of those ``dims``. Only data with coordinates given by selections</span>
<span class="sd">            are fit to . If no selections given, everything is fit to.</span>
<span class="sd">            - kwargs of ``curve_fit``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Saves resulting :class:`~analysis.analysis.baseAnalysis.analyzedFit` object</span>
<span class="sd">            to a new attribute, named ``(yname)_azimuth_fit``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined_angle_fit_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Need to run combine_fit_params_inplane first&quot;</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span> <span class="o">+</span> <span class="s1">&#39;_azimuth_fit&#39;</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_angle_fit_params</span><span class="p">,</span> <span class="n">fit_func</span><span class="p">,</span> <span class="n">guess_func</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">ANGLE_DIM</span><span class="p">,</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname</span><span class="o">+</span><span class="s1">&#39;_err&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Joseph Mittelstaedt, Saba Karimeddiny.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1alpha',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>